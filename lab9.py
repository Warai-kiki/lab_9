import timeit #імпортуємо для того щоб дізнатись час роботи програми
from random import randint # вводимо рандом
import numpy as np # вводимо бібліотеку для масивів
# всі алгоритми сортування для зручності (щоб не повторювати їх по декілька разів) будуть записані
# через функції і далі будуть викликатись для кожного масиву
def bubble_1(a):  # сортування бульбашкою за спаданням
    count = 0 # вводимо лічильник для обрахунку кількості перестановок (він буде фігурувати у всіх циклах
    # під одною назвою, тому в наступних циклах його коментувати не буду)
    n = len(a) # заводимо змінну з довжиною масиву
    i = 0 # вводимо нову змінну для лічильника
    flag = True # прапорець для прискорення роботи програми
    while flag: # вводимо цикл алгоритму
        flag = False # міняємо значеня змінної, на той випадок, якщо жодної перестановки не буде
        # тоді через невідповідність умові циклу, нас з нього викине
        for j in range(n-i-1): # перебираємо кожен елемент послідовності, крім останнього
# на кожній наступній ітерації кількість елементів, які будуть перевірятись зменшується, відповідно ті елементи,
# що перевірялись попередні рази не будуть знову перевірятись
            if a[j]<a[j+1]: # якщо даний елемент менший за наступний елемент
                a[j],a[j+1]=a[j+1],a[j] # міняємо їх місцями
                count+=1
                flag = True # прапорець відповідає умові, отже повторюємо цикл
        i+=1 # після кожної ітерації збільшуємо лічильник
    print(f'Число перестановок та порівнянь: {count}')

    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return a # виводимо відсортований масив

def bubble_2(a): # сортування бульбашкою за зростанням
    # тут відбувається теж саме, що і в попередньому алгоритмі
    n = len(a)
    i = 0
    flag = True
    count = 0
    while flag:
        flag = False
        for j in range(n-i-1):
            if a[j]>a[j+1]: # за винятком одного знаку, щоб сортувати за зростанням
                a[j],a[j+1]=a[j+1],a[j]
                count += 1
                flag = True
        i+=1
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return a

def selection_1(b): # сортування вибором за зростанням
    n = len(b) # заводимо змінну з довжиною масиву
    count = 0
    for i in range(n-1): # перебираємо кожен елемент масиву крім останнього
        min = i # присвоюємо дане значення як мінімальне
        for j in range(i+1,n): # перебираємо кожен елемент масиву від наступної позиціїї до останньої в масиві
            if b[j]<b[min]: # якщо даний елемент менше раніше присвоєного мінімального
                min = j # переприсвоюємо мінімальному значенню дану змінну
                count+=1
        b[i],b[min] = b[min],b[i] # міняємо місцями елементи
        count+=1
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return b

def selection_2(b): # сортування вибором за спаданням
    # тут відбувається теж саме, що і в попередньому алгоритмі
    n = len(b)
    count = 0
    for i in range(n-1):
        max = i # за винятком того, що тепер будемо орієнтуватись на максимальне значеня
        for j in range(i+1,n):
            if b[j]>b[max]: # тому також міняємо знак у цій перевірці
                max = j
                count+=1
        b[i],b[max] = b[max],b[i]
        count+=1
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return b

def insertion_1(c): # сортування вставками за зростанням
    n = len(c) # заводимо змінну з довжиною масиву
    count = 0
    for i in range(1,n): # перебираємо кожен елемент масиву крім першого
        j = i-1 # вводимо змінну для перевірки переднього значення, по суті лічильник
        key = c[i] # вводимо ключ, який допоможе нам в порівняннях
        while j>=0 and c[j]>key: # якщо відповідає умовам(перша- щоб не виникла помилка, индекс стане від'ємним,
            # друга - по суті чи дане значення більше за наступне)
            c[j+1]=c[j] # то значення даного елементу підставляється в наступний, при цьому сам залишається з таким значенням
            j-=1 # зменшуємо індекс, щоб далі перевіряти чипотрібно підставляти це значення праворуч по масиву
            count+=1
        c[j+1]=key # тепер на  місце даного індексу вставляємо значення ключа
        count+=1
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return c # повертаємо відсортований масив

def insertion_2(c): # сортування вставками за спаданням
    # тут відбувається теж саме, що і в попередньому алгоритмі
    n = len(c)
    count = 0
    for i in range(1,n):
        j = i-1
        key = c[i]
        while j>=0 and c[j]<key: # за винятком одного знаку, щоб сортувати за спаданням
            c[j+1]=c[j]
            j-=1
            count+=1
        c[j+1]=key
        count += 1
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return c

def coctail_1(d): # сортування перемішуванням за зростанням
    n = range(len(d) - 1) # вводимо змінну з довжиною масиву для проходження по масиву
    count = 0
    while True:
        for indices in (n, reversed(n)): # проходимо масив зліва направо
            swapped = False
            for i in indices: # проходимоось по елементам
                if d[i] > d[i + 1]: # якщо попередній більший за наступний
                    d[i], d[i + 1] = d[i + 1], d[i] # міняємо їх місцями
                    swapped = True # зали
                    count+=1
            if not swapped: # якщо не відбулось жодної зміни
                print(f'Число перестановок та порівнянь: {count}')
                t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
                print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
                return d # повертаємо масив

def coctail_2(d): # сортування перемішуванням за спаданням
    # тут відбувається теж саме, що і в попередньому алгоритмі
    n = range(len(d) - 1)
    count = 0
    while True:
        for indices in (n, reversed(n)):
            swapped = False
            for i in indices:
                if d[i] < d[i + 1]: # за винятком одного знаку, щоб сортувати за спаданням
                    d[i], d[i + 1] = d[i + 1], d[i]
                    swapped = True
                    count+=1
            if not swapped:
                print(f'Число перестановок та порівнянь: {count}')
                t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
                print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
                return d

def shell_1(e): # сортування Шелла за зростанням
    inc = len(e) // 2 # ділимо наш масив на частини
    count = 0
    while inc: # основній цикл
        for i, el in enumerate(e): # enumerate створює кортеж, що складається з двох елементів - індекса і самого елемента
            while i >= inc and e[i - inc] > el: # цикл, що порівнює елементи
                e[i] = e[i - inc] # присвоєння елементу відповідного значення
                i -= inc # зменшення
                count+=1
            e[i] = el # якщо елемент не відповідає умові циклу, то в цикл не входимо і відбувається присвоєння іншого значення
        inc = 1 if inc == 2 else int(inc * 5.0 / 11) # якщо величина частинки масиву дорівнює 2 то присвоюємо
        # їй значення 1 в інших випадках присвоюємо значення задане в дужках
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return e

def shell_2(e): # сортування Шелла за спаданням
    # тут відбувається теж саме, що і в попередньому алгоритмі
    inc = len(e) // 2
    count = 0
    while inc:
        for i, el in enumerate(e):
            while i >= inc and e[i - inc] < el: # за винятком одного знаку, щоб сортувати за спаданням
                e[i] = e[i - inc]
                i -= inc
                count+=1
            e[i] = el
        inc = 1 if inc == 2 else int(inc * 5.0 / 11)
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return e

def heapify_1(f, heap_size, root_index): # допоміжна функція для сортування за зростанням
    largest = root_index # індекс найбільшого елемента вважаєм корінним індексом
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2
    count = 0
    if left_child < heap_size and f[left_child] > f[largest]: # якщо лівий потомок кореня це допустимий індекс,
        # а елемент більший ніж даний
        largest = left_child # обновлюємо найбільший елемент
        count+=1
    if right_child < heap_size and f[right_child] > f[largest]: # те ж саме для правого потомка кореня
        largest = right_child
        count+=1
    if largest != root_index: # якщо найбільший елемент не більший за корінний
        f[root_index], f[largest] = f[largest], f[root_index] # вони міняються місцями
        count+=1
        heapify_1(f, heap_size, largest)

def heap_1(f): # пірамідальне сортування за зростанням
    n = len(f) # вводимо елемент зі значенням довжини масиву
    count = 0
    for i in range(n, -1, -1): # перебираемо елементи зліва направо
        heapify_1(f, n, i) # використовуємо допоміжну функцію
        count+= 1
    for i in range(n - 1, 0, -1): # знову перебираємо елементи  масиву
        f[i], f[0] = f[0], f[i] # переносимо елемент в кінець масиву
        heapify_1(f, i, 0)
        count+= 1
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return f

def heapify_2(f, heap_size, root_index): # допоміжна функція для сортування за спаданням
    # тут відбувається теж саме, що і в попередньому алгоритмі
    largest = root_index
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2
    count = 0
    if left_child < heap_size and f[left_child] < f[largest]: # за винятком одного знаку в двох місцях, щоб сортувати за спаданням
        largest = left_child
        count+=1
    if right_child < heap_size and f[right_child] < f[largest]: # тут те саме, що і рядком вище
        largest = right_child
        count+=1
    if largest != root_index:
        f[root_index], f[largest] = f[largest], f[root_index]
        count+=1
        heapify_2(f, heap_size, largest)

# відмінність для сортування за зростанням і спаданням лише в допоміжній функції
def heap_2(f): # пірамідальне сортування за спаданням
    n = len(f)
    count = 0
    for i in range(n, -1, -1):
        heapify_2(f, n, i)
        count+= 1
    for i in range(n - 1, 0, -1):
        f[i], f[0] = f[0], f[i]
        heapify_2(f, i, 0)
        count+= 1
    print(f'Число перестановок та порівнянь: {count}')
    t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
    print('Час роботи алгоритму: {:.3f}'.format(t))  # показує час виконання алгоритму
    return f

while True:
    while True:
        try:#перевірка
            n = input('Хочете самостійно ввести послідовність чисел? Напишіть так чи ні ') #користувач вибирає рандом чи ведення власноруч
            if n == 'так':
                print('Введіть елементи масиву:')
                x = np.array([int(input()) for i in range(30)])
                print(f'Ваш масив:\n{x}')
            else:
                x = np.array([randint(-1000, 2000) for i in range(100)])
            break
        except ValueError or NameError or TypeError:
            print('Введіть ще раз')

    print(f'Сортування бульбашкою за спаданням')
    print(f'{bubble_1(x)}\n')
    print(f'Сортування бульбашкою за зростанням')
    print(f'{bubble_2(x)}\n')
    print(f'Сортування вибором за зростанням')
    print(f'{selection_1(x)}\n')
    print(f'Сортування вибором за спаданням')
    print(f'{selection_2(x)}\n')
    print(f'Сортування вставками за зростанням')
    print(f'{insertion_1(x)}\n')
    print(f'Сортування вставками за спаданням')
    print(f'{insertion_2(x)}\n')
    print(f'Сортування перемішуванням за зростанням')
    print(f'{coctail_1(x)}\n')
    print(f'Сортування перемішуванням за спаданням')
    print(f'{coctail_2(x)}\n')
    print(f'Сортування Шелла за зростанням')
    print(f'{shell_1(x)}\n')
    print(f'Сортування Шелла за спаданням')
    print(f'{shell_2(x)}\n')
    print(f'Пірамідальне сортування за зростанням')
    print(f'{heap_1(x)}\n')
    print(f'Пірамідальне сортування за спаданням')
    print(f'{heap_2(x)}\n')

    print('Запустити програму ще раз? Напишіть так чи ні')
    l = input('')  # цикл умові якщо хоче користувач ще раз запустити програму
    if l == 'так':
        continue  # програма починається заново
    else:
        break  # цикл обривається

t = timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
print('Час роботи програми: {:.3f}'.format(t))  # показує час виконання програми